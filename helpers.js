const fs = require("fs");
const crypto = require("crypto");
const path = require("path");
const { Timestamp, FieldValue } = require("firebase-admin/firestore");
const db = require("./firebase");
const config = require("./config");


const generateToken = async () => {
  try {
    const encodedCredentials = Buffer.from(
      `${config.CONSUMER_KEY}:${config.CONSUMER_SECRET}`
    ).toString("base64");

    const response = await fetch(
      `${config.BASE_URL}/oauth/v1/generate?grant_type=client_credentials`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${encodedCredentials}`,
        },
      }
    );

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();
    return data.access_token;
  } catch (error) {
    console.error("Error fetching access token:", error.message);
    throw new Error("Failed to get access token");
  }
};
// generateToken()
//   .then((data) => console.log(`Access token: ${data}`))
//   .catch((err) => console.error(err));


// `SecurityCredential` in the B2C request body is generated by encrypting
// the API Inititor password using public key certificate provided by Safaricom.
const generateSecurityCredential = (password, certPath) => {
  try {
    const cert = fs.readFileSync(path.resolve(certPath), "utf8");
    const publicKey = crypto.createPublicKey(cert);
    const buffer = Buffer.from(password);
    const encrypted = crypto.publicEncrypt(
      {
        key: publicKey,
        padding: crypto.constants.RSA_PKCS1_PADDING,
      },
      buffer
    );
    return encrypted.toString("base64");
  } catch (error) {
    console.error("Error generating security credentials", error.message);
    throw new Error("Failed to generate security credential");
  }
};
// console.log(
//   generateSecurityCredential(
//     config.INITIATOR_PASSWORD,
//     config.SECURITY_CERT_PATH
//   )
// );


const processMpesaResponse = async (req, res) => {
  try {
    const { Result } = req.body;
    if (!Result) {
      return res.status(400).json({ error: "Invalid response structure." });
    }

    // Determine the type based on the request path
    let type = "unknown";
    if (req.path.includes("withdraw")) type = "withdraw";
    else if (req.path.includes("reversal")) type = "reversal";
    else if (req.path.includes("transaction-status")) type = "status_check";

    // Extracting common fields
    const data = {
      type,
      resultCode: Result.ResultCode,
      description: Result.ResultDesc,
      mpesaCode: Result.TransactionID,
      conversationID: Result.ConversationID,
      originatorConversationID: Result.OriginatorConversationID,
      resultData: Result?.ResultParameters || {},
      updatedAt: Timestamp.now()
    };

    console.log(data); // Log result data

    const resultItems = Result?.ResultParameters?.ResultParameter || [];
    const getValue = (key) =>
      resultItems.find((item) => item.Key === key)?.Value;

    await db
      .collection("transactions")
      .doc(data.conversationID)
      .set(data);

    if (type === "withdraw" || type === "reversal") {
      const amount = parseFloat(getValue("TransactionAmount") || getValue("Amount") || 0);

      const userQuery = db
        .collection("users")
        .where("conversationID", "==", data.conversationID)
        .limit(1);
      const snapshot = await userQuery.get();

      if (!snapshot.empty) {
        const docRef = snapshot.docs[0].ref;
        await docRef.update({ balance: FieldValue.increment(-amount) });
        console.log(
          `Balance updated successfully for user with conversationID: ${data.conversationID}`
        );
      }
    }

    return res.status(200).json({ status: "success" });
  } catch (error) {
    console.error("Error processing response:", error.message);
    return res.status(500).json({ error: "Internal server error" });
  }
};


const registerURLs = async () => {
  try {
    const token = await generateToken();

    const requestBody = {
      ShortCode: config.SHORTCODE,
      ResponseType: "Completed",
      ConfirmationURL: `${config.BASE_API_URL}/confirmation`,
      ValidationURL: `${config.BASE_API_URL}/validation`,
    };

    const response = await fetch(
      `${config.BASE_URL}/mpesa/c2b/v1/registerurl`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody),
      }
    );

    return await response.json();
  } catch (error) {
    console.error(error.message);
  }
};
// registerURLs()
//   .then((data) => console.log(data))
//   .catch((error) => console.error("Error", error));


const formatPhoneNumber = (phone) => {
  let cleaned = phone.replace(/\D/g, "");
  const phoneRegex =
    /^(?:\+2547\d{8}|2547\d{8}|07\d{8}|7\d{8}|\+2541\d{8}|2541\d{8}|01\d{8}|1\d{8})$/;

  if (!phoneRegex.test(cleaned)) {
    return { success: false, error: "Invalid phone number format." };
  }

  // Normalize number to '254XXXXXXXXX' format
  if (cleaned.startsWith("0")) {
    cleaned = `254${cleaned.substring(1)}`;
  } else if (cleaned.startsWith("+254")) {
    cleaned = cleaned.substring(1);
  }

  return { success: true, formattedPhone: cleaned };
};


// Saving/update user and transaction details for demo purposes
const saveUpdateUser = async (phone, merchantRequestID) => {
  try {
    const userRef = db.collection("users").doc(phone);
    const userDoc = await userRef.get();

    if (userDoc.exists) {
      await userRef.update({
        merchantRequestID,
        updatedAt: Timestamp.now(),
      });
    } else {
      await userRef.set({
        phone,
        balance: 0,
        merchantRequestID,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
    }
  } catch (error) {
    console.error("Error saving user:", error.message);
  }
};


const getUserDetails = async (phone) => {
  try {
    const userRef = db.collection("users").doc(phone);
    const userDoc = await userRef.get();

    if (userDoc.exists) {
      return userDoc.data();
    }

    return null;
  } catch (error) {
    console.error("Error retrieving user details:", error.message);
    return null;
  }
};


const updateTransaction = async (
  merchantRequestID,
  status,
  amount,
  mpesaCode,
  transactionDate
) => {
  try {
    const docRef = db.collection("deposits").doc(merchantRequestID);

    const docSnap = await docRef.get();
    if (!docSnap.exists) {
      console.log(
        `No transaction found with merchantRequestID: ${merchantRequestID}`
      );
      return;
    }

    await docRef.update({
      amount,
      mpesaCode,
      transactionDate,
      status,
      updatedAt: Timestamp.now(),
    });

    console.log(`Transaction ${merchantRequestID} updated successfully.`);
  } catch (error) {
    console.error("Error updating transaction:", error.message);
  }
};


module.exports = {
  generateToken,
  generateSecurityCredential,
  processMpesaResponse,
  formatPhoneNumber,
  saveUpdateUser,
  updateTransaction,
  getUserDetails,
};
